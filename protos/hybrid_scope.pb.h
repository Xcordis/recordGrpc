// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hybrid_scope.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hybrid_5fscope_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hybrid_5fscope_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hybrid_5fscope_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hybrid_5fscope_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hybrid_5fscope_2eproto;
namespace hybrid_scope {
class DeviceInfo;
struct DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class EchoRequest;
struct EchoRequestDefaultTypeInternal;
extern EchoRequestDefaultTypeInternal _EchoRequest_default_instance_;
class EchoResponse;
struct EchoResponseDefaultTypeInternal;
extern EchoResponseDefaultTypeInternal _EchoResponse_default_instance_;
class RpcResult;
struct RpcResultDefaultTypeInternal;
extern RpcResultDefaultTypeInternal _RpcResult_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class Void;
struct VoidDefaultTypeInternal;
extern VoidDefaultTypeInternal _Void_default_instance_;
class WgConfigRequest;
struct WgConfigRequestDefaultTypeInternal;
extern WgConfigRequestDefaultTypeInternal _WgConfigRequest_default_instance_;
class WgExecRequest;
struct WgExecRequestDefaultTypeInternal;
extern WgExecRequestDefaultTypeInternal _WgExecRequest_default_instance_;
class WgGatewayConfig;
struct WgGatewayConfigDefaultTypeInternal;
extern WgGatewayConfigDefaultTypeInternal _WgGatewayConfig_default_instance_;
class WgKeypair;
struct WgKeypairDefaultTypeInternal;
extern WgKeypairDefaultTypeInternal _WgKeypair_default_instance_;
class WgPeerInfo;
struct WgPeerInfoDefaultTypeInternal;
extern WgPeerInfoDefaultTypeInternal _WgPeerInfo_default_instance_;
class WgPrivateKey;
struct WgPrivateKeyDefaultTypeInternal;
extern WgPrivateKeyDefaultTypeInternal _WgPrivateKey_default_instance_;
class WgPublicKey;
struct WgPublicKeyDefaultTypeInternal;
extern WgPublicKeyDefaultTypeInternal _WgPublicKey_default_instance_;
class WgShutdownRequest;
struct WgShutdownRequestDefaultTypeInternal;
extern WgShutdownRequestDefaultTypeInternal _WgShutdownRequest_default_instance_;
class WgStartupRequest;
struct WgStartupRequestDefaultTypeInternal;
extern WgStartupRequestDefaultTypeInternal _WgStartupRequest_default_instance_;
class WgTunnelConfig;
struct WgTunnelConfigDefaultTypeInternal;
extern WgTunnelConfigDefaultTypeInternal _WgTunnelConfig_default_instance_;
}  // namespace hybrid_scope
PROTOBUF_NAMESPACE_OPEN
template<> ::hybrid_scope::DeviceInfo* Arena::CreateMaybeMessage<::hybrid_scope::DeviceInfo>(Arena*);
template<> ::hybrid_scope::EchoRequest* Arena::CreateMaybeMessage<::hybrid_scope::EchoRequest>(Arena*);
template<> ::hybrid_scope::EchoResponse* Arena::CreateMaybeMessage<::hybrid_scope::EchoResponse>(Arena*);
template<> ::hybrid_scope::RpcResult* Arena::CreateMaybeMessage<::hybrid_scope::RpcResult>(Arena*);
template<> ::hybrid_scope::UserInfo* Arena::CreateMaybeMessage<::hybrid_scope::UserInfo>(Arena*);
template<> ::hybrid_scope::Void* Arena::CreateMaybeMessage<::hybrid_scope::Void>(Arena*);
template<> ::hybrid_scope::WgConfigRequest* Arena::CreateMaybeMessage<::hybrid_scope::WgConfigRequest>(Arena*);
template<> ::hybrid_scope::WgExecRequest* Arena::CreateMaybeMessage<::hybrid_scope::WgExecRequest>(Arena*);
template<> ::hybrid_scope::WgGatewayConfig* Arena::CreateMaybeMessage<::hybrid_scope::WgGatewayConfig>(Arena*);
template<> ::hybrid_scope::WgKeypair* Arena::CreateMaybeMessage<::hybrid_scope::WgKeypair>(Arena*);
template<> ::hybrid_scope::WgPeerInfo* Arena::CreateMaybeMessage<::hybrid_scope::WgPeerInfo>(Arena*);
template<> ::hybrid_scope::WgPrivateKey* Arena::CreateMaybeMessage<::hybrid_scope::WgPrivateKey>(Arena*);
template<> ::hybrid_scope::WgPublicKey* Arena::CreateMaybeMessage<::hybrid_scope::WgPublicKey>(Arena*);
template<> ::hybrid_scope::WgShutdownRequest* Arena::CreateMaybeMessage<::hybrid_scope::WgShutdownRequest>(Arena*);
template<> ::hybrid_scope::WgStartupRequest* Arena::CreateMaybeMessage<::hybrid_scope::WgStartupRequest>(Arena*);
template<> ::hybrid_scope::WgTunnelConfig* Arena::CreateMaybeMessage<::hybrid_scope::WgTunnelConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hybrid_scope {

// ===================================================================

class EchoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.EchoRequest) */ {
 public:
  inline EchoRequest() : EchoRequest(nullptr) {}
  ~EchoRequest() override;
  explicit PROTOBUF_CONSTEXPR EchoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EchoRequest(const EchoRequest& from);
  EchoRequest(EchoRequest&& from) noexcept
    : EchoRequest() {
    *this = ::std::move(from);
  }

  inline EchoRequest& operator=(const EchoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EchoRequest& operator=(EchoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EchoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EchoRequest* internal_default_instance() {
    return reinterpret_cast<const EchoRequest*>(
               &_EchoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EchoRequest& a, EchoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EchoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EchoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EchoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EchoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EchoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EchoRequest& from) {
    EchoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EchoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.EchoRequest";
  }
  protected:
  explicit EchoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.EchoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class EchoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.EchoResponse) */ {
 public:
  inline EchoResponse() : EchoResponse(nullptr) {}
  ~EchoResponse() override;
  explicit PROTOBUF_CONSTEXPR EchoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EchoResponse(const EchoResponse& from);
  EchoResponse(EchoResponse&& from) noexcept
    : EchoResponse() {
    *this = ::std::move(from);
  }

  inline EchoResponse& operator=(const EchoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EchoResponse& operator=(EchoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EchoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EchoResponse* internal_default_instance() {
    return reinterpret_cast<const EchoResponse*>(
               &_EchoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EchoResponse& a, EchoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EchoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EchoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EchoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EchoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EchoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EchoResponse& from) {
    EchoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EchoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.EchoResponse";
  }
  protected:
  explicit EchoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.EchoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class Void final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hybrid_scope.Void) */ {
 public:
  inline Void() : Void(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Void(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Void(const Void& from);
  Void(Void&& from) noexcept
    : Void() {
    *this = ::std::move(from);
  }

  inline Void& operator=(const Void& from) {
    CopyFrom(from);
    return *this;
  }
  inline Void& operator=(Void&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Void& default_instance() {
    return *internal_default_instance();
  }
  static inline const Void* internal_default_instance() {
    return reinterpret_cast<const Void*>(
               &_Void_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Void& a, Void& b) {
    a.Swap(&b);
  }
  inline void Swap(Void* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Void* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Void* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Void>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Void& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Void& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.Void";
  }
  protected:
  explicit Void(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hybrid_scope.Void)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class RpcResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.RpcResult) */ {
 public:
  inline RpcResult() : RpcResult(nullptr) {}
  ~RpcResult() override;
  explicit PROTOBUF_CONSTEXPR RpcResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RpcResult(const RpcResult& from);
  RpcResult(RpcResult&& from) noexcept
    : RpcResult() {
    *this = ::std::move(from);
  }

  inline RpcResult& operator=(const RpcResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcResult& operator=(RpcResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RpcResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const RpcResult* internal_default_instance() {
    return reinterpret_cast<const RpcResult*>(
               &_RpcResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RpcResult& a, RpcResult& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RpcResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RpcResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RpcResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RpcResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RpcResult& from) {
    RpcResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.RpcResult";
  }
  protected:
  explicit RpcResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.RpcResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class WgPeerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.WgPeerInfo) */ {
 public:
  inline WgPeerInfo() : WgPeerInfo(nullptr) {}
  ~WgPeerInfo() override;
  explicit PROTOBUF_CONSTEXPR WgPeerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WgPeerInfo(const WgPeerInfo& from);
  WgPeerInfo(WgPeerInfo&& from) noexcept
    : WgPeerInfo() {
    *this = ::std::move(from);
  }

  inline WgPeerInfo& operator=(const WgPeerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WgPeerInfo& operator=(WgPeerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WgPeerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WgPeerInfo* internal_default_instance() {
    return reinterpret_cast<const WgPeerInfo*>(
               &_WgPeerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(WgPeerInfo& a, WgPeerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WgPeerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WgPeerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WgPeerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WgPeerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WgPeerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WgPeerInfo& from) {
    WgPeerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WgPeerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.WgPeerInfo";
  }
  protected:
  explicit WgPeerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubkeyFieldNumber = 1,
    kPrikeyFieldNumber = 2,
    kIpv4FieldNumber = 3,
    kIpv6FieldNumber = 4,
    kMaskFieldNumber = 6,
    kPortFieldNumber = 5,
  };
  // string pubkey = 1;
  void clear_pubkey();
  const std::string& pubkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pubkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pubkey();
  PROTOBUF_NODISCARD std::string* release_pubkey();
  void set_allocated_pubkey(std::string* pubkey);
  private:
  const std::string& _internal_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkey(const std::string& value);
  std::string* _internal_mutable_pubkey();
  public:

  // string prikey = 2;
  void clear_prikey();
  const std::string& prikey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prikey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prikey();
  PROTOBUF_NODISCARD std::string* release_prikey();
  void set_allocated_prikey(std::string* prikey);
  private:
  const std::string& _internal_prikey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prikey(const std::string& value);
  std::string* _internal_mutable_prikey();
  public:

  // string ipv4 = 3;
  void clear_ipv4();
  const std::string& ipv4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipv4(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipv4();
  PROTOBUF_NODISCARD std::string* release_ipv4();
  void set_allocated_ipv4(std::string* ipv4);
  private:
  const std::string& _internal_ipv4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipv4(const std::string& value);
  std::string* _internal_mutable_ipv4();
  public:

  // string ipv6 = 4;
  void clear_ipv6();
  const std::string& ipv6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipv6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipv6();
  PROTOBUF_NODISCARD std::string* release_ipv6();
  void set_allocated_ipv6(std::string* ipv6);
  private:
  const std::string& _internal_ipv6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipv6(const std::string& value);
  std::string* _internal_mutable_ipv6();
  public:

  // string mask = 6;
  void clear_mask();
  const std::string& mask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mask();
  PROTOBUF_NODISCARD std::string* release_mask();
  void set_allocated_mask(std::string* mask);
  private:
  const std::string& _internal_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mask(const std::string& value);
  std::string* _internal_mutable_mask();
  public:

  // uint32 port = 5;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.WgPeerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prikey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipv4_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipv6_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mask_;
    uint32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class WgGatewayConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.WgGatewayConfig) */ {
 public:
  inline WgGatewayConfig() : WgGatewayConfig(nullptr) {}
  ~WgGatewayConfig() override;
  explicit PROTOBUF_CONSTEXPR WgGatewayConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WgGatewayConfig(const WgGatewayConfig& from);
  WgGatewayConfig(WgGatewayConfig&& from) noexcept
    : WgGatewayConfig() {
    *this = ::std::move(from);
  }

  inline WgGatewayConfig& operator=(const WgGatewayConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline WgGatewayConfig& operator=(WgGatewayConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WgGatewayConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const WgGatewayConfig* internal_default_instance() {
    return reinterpret_cast<const WgGatewayConfig*>(
               &_WgGatewayConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WgGatewayConfig& a, WgGatewayConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(WgGatewayConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WgGatewayConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WgGatewayConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WgGatewayConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WgGatewayConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WgGatewayConfig& from) {
    WgGatewayConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WgGatewayConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.WgGatewayConfig";
  }
  protected:
  explicit WgGatewayConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 2,
    kNameFieldNumber = 4,
    kGatewayUuidFieldNumber = 6,
    kGatewayPublicKeyFieldNumber = 7,
    kTransportFieldNumber = 10,
    kVirtualIpv4FieldNumber = 13,
    kVirtualIpv6FieldNumber = 14,
    kIdFieldNumber = 1,
    kWireguardPortFieldNumber = 3,
    kGatewayIdFieldNumber = 5,
    kKeepAliveFieldNumber = 9,
    kObfKeyFieldNumber = 8,
    kModeFieldNumber = 11,
    kEncryptModeFieldNumber = 12,
    kMtuFieldNumber = 15,
  };
  // string ip = 2;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string gateway_uuid = 6;
  void clear_gateway_uuid();
  const std::string& gateway_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gateway_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gateway_uuid();
  PROTOBUF_NODISCARD std::string* release_gateway_uuid();
  void set_allocated_gateway_uuid(std::string* gateway_uuid);
  private:
  const std::string& _internal_gateway_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway_uuid(const std::string& value);
  std::string* _internal_mutable_gateway_uuid();
  public:

  // string gateway_public_key = 7;
  void clear_gateway_public_key();
  const std::string& gateway_public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gateway_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gateway_public_key();
  PROTOBUF_NODISCARD std::string* release_gateway_public_key();
  void set_allocated_gateway_public_key(std::string* gateway_public_key);
  private:
  const std::string& _internal_gateway_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway_public_key(const std::string& value);
  std::string* _internal_mutable_gateway_public_key();
  public:

  // string transport = 10;
  void clear_transport();
  const std::string& transport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transport();
  PROTOBUF_NODISCARD std::string* release_transport();
  void set_allocated_transport(std::string* transport);
  private:
  const std::string& _internal_transport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transport(const std::string& value);
  std::string* _internal_mutable_transport();
  public:

  // string virtual_ipv4 = 13;
  void clear_virtual_ipv4();
  const std::string& virtual_ipv4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_virtual_ipv4(ArgT0&& arg0, ArgT... args);
  std::string* mutable_virtual_ipv4();
  PROTOBUF_NODISCARD std::string* release_virtual_ipv4();
  void set_allocated_virtual_ipv4(std::string* virtual_ipv4);
  private:
  const std::string& _internal_virtual_ipv4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_virtual_ipv4(const std::string& value);
  std::string* _internal_mutable_virtual_ipv4();
  public:

  // string virtual_ipv6 = 14;
  void clear_virtual_ipv6();
  const std::string& virtual_ipv6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_virtual_ipv6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_virtual_ipv6();
  PROTOBUF_NODISCARD std::string* release_virtual_ipv6();
  void set_allocated_virtual_ipv6(std::string* virtual_ipv6);
  private:
  const std::string& _internal_virtual_ipv6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_virtual_ipv6(const std::string& value);
  std::string* _internal_mutable_virtual_ipv6();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // uint32 wireguard_port = 3;
  void clear_wireguard_port();
  uint32_t wireguard_port() const;
  void set_wireguard_port(uint32_t value);
  private:
  uint32_t _internal_wireguard_port() const;
  void _internal_set_wireguard_port(uint32_t value);
  public:

  // uint32 gateway_id = 5;
  void clear_gateway_id();
  uint32_t gateway_id() const;
  void set_gateway_id(uint32_t value);
  private:
  uint32_t _internal_gateway_id() const;
  void _internal_set_gateway_id(uint32_t value);
  public:

  // uint32 keep_alive = 9;
  void clear_keep_alive();
  uint32_t keep_alive() const;
  void set_keep_alive(uint32_t value);
  private:
  uint32_t _internal_keep_alive() const;
  void _internal_set_keep_alive(uint32_t value);
  public:

  // uint64 obf_key = 8;
  void clear_obf_key();
  uint64_t obf_key() const;
  void set_obf_key(uint64_t value);
  private:
  uint64_t _internal_obf_key() const;
  void _internal_set_obf_key(uint64_t value);
  public:

  // uint32 mode = 11;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // uint32 encrypt_mode = 12;
  void clear_encrypt_mode();
  uint32_t encrypt_mode() const;
  void set_encrypt_mode(uint32_t value);
  private:
  uint32_t _internal_encrypt_mode() const;
  void _internal_set_encrypt_mode(uint32_t value);
  public:

  // uint32 mtu = 15;
  void clear_mtu();
  uint32_t mtu() const;
  void set_mtu(uint32_t value);
  private:
  uint32_t _internal_mtu() const;
  void _internal_set_mtu(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.WgGatewayConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transport_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr virtual_ipv4_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr virtual_ipv6_;
    int32_t id_;
    uint32_t wireguard_port_;
    uint32_t gateway_id_;
    uint32_t keep_alive_;
    uint64_t obf_key_;
    uint32_t mode_;
    uint32_t encrypt_mode_;
    uint32_t mtu_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class WgTunnelConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.WgTunnelConfig) */ {
 public:
  inline WgTunnelConfig() : WgTunnelConfig(nullptr) {}
  ~WgTunnelConfig() override;
  explicit PROTOBUF_CONSTEXPR WgTunnelConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WgTunnelConfig(const WgTunnelConfig& from);
  WgTunnelConfig(WgTunnelConfig&& from) noexcept
    : WgTunnelConfig() {
    *this = ::std::move(from);
  }

  inline WgTunnelConfig& operator=(const WgTunnelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline WgTunnelConfig& operator=(WgTunnelConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WgTunnelConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const WgTunnelConfig* internal_default_instance() {
    return reinterpret_cast<const WgTunnelConfig*>(
               &_WgTunnelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WgTunnelConfig& a, WgTunnelConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(WgTunnelConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WgTunnelConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WgTunnelConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WgTunnelConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WgTunnelConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WgTunnelConfig& from) {
    WgTunnelConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WgTunnelConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.WgTunnelConfig";
  }
  protected:
  explicit WgTunnelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerInfoFieldNumber = 1,
    kGatewayInfoFieldNumber = 2,
  };
  // .hybrid_scope.WgPeerInfo peer_info = 1;
  bool has_peer_info() const;
  private:
  bool _internal_has_peer_info() const;
  public:
  void clear_peer_info();
  const ::hybrid_scope::WgPeerInfo& peer_info() const;
  PROTOBUF_NODISCARD ::hybrid_scope::WgPeerInfo* release_peer_info();
  ::hybrid_scope::WgPeerInfo* mutable_peer_info();
  void set_allocated_peer_info(::hybrid_scope::WgPeerInfo* peer_info);
  private:
  const ::hybrid_scope::WgPeerInfo& _internal_peer_info() const;
  ::hybrid_scope::WgPeerInfo* _internal_mutable_peer_info();
  public:
  void unsafe_arena_set_allocated_peer_info(
      ::hybrid_scope::WgPeerInfo* peer_info);
  ::hybrid_scope::WgPeerInfo* unsafe_arena_release_peer_info();

  // .hybrid_scope.WgGatewayConfig gateway_info = 2;
  bool has_gateway_info() const;
  private:
  bool _internal_has_gateway_info() const;
  public:
  void clear_gateway_info();
  const ::hybrid_scope::WgGatewayConfig& gateway_info() const;
  PROTOBUF_NODISCARD ::hybrid_scope::WgGatewayConfig* release_gateway_info();
  ::hybrid_scope::WgGatewayConfig* mutable_gateway_info();
  void set_allocated_gateway_info(::hybrid_scope::WgGatewayConfig* gateway_info);
  private:
  const ::hybrid_scope::WgGatewayConfig& _internal_gateway_info() const;
  ::hybrid_scope::WgGatewayConfig* _internal_mutable_gateway_info();
  public:
  void unsafe_arena_set_allocated_gateway_info(
      ::hybrid_scope::WgGatewayConfig* gateway_info);
  ::hybrid_scope::WgGatewayConfig* unsafe_arena_release_gateway_info();

  // @@protoc_insertion_point(class_scope:hybrid_scope.WgTunnelConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::hybrid_scope::WgPeerInfo* peer_info_;
    ::hybrid_scope::WgGatewayConfig* gateway_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit PROTOBUF_CONSTEXPR UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserInfo& from) {
    UserInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kTenantNameFieldNumber = 34,
    kUserIdFieldNumber = 2,
    kOrgIdFieldNumber = 3,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string tenant_name = 34;
  void clear_tenant_name();
  const std::string& tenant_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenant_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenant_name();
  PROTOBUF_NODISCARD std::string* release_tenant_name();
  void set_allocated_tenant_name(std::string* tenant_name);
  private:
  const std::string& _internal_tenant_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenant_name(const std::string& value);
  std::string* _internal_mutable_tenant_name();
  public:

  // uint64 user_id = 2;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // uint64 org_id = 3;
  void clear_org_id();
  uint64_t org_id() const;
  void set_org_id(uint64_t value);
  private:
  uint64_t _internal_org_id() const;
  void _internal_set_org_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenant_name_;
    uint64_t user_id_;
    uint64_t org_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.DeviceInfo) */ {
 public:
  inline DeviceInfo() : DeviceInfo(nullptr) {}
  ~DeviceInfo() override;
  explicit PROTOBUF_CONSTEXPR DeviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceInfo& from) {
    DeviceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.DeviceInfo";
  }
  protected:
  explicit DeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceUuidFieldNumber = 2,
    kDeviceIdFieldNumber = 1,
  };
  // string device_uuid = 2;
  void clear_device_uuid();
  const std::string& device_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_uuid();
  PROTOBUF_NODISCARD std::string* release_device_uuid();
  void set_allocated_device_uuid(std::string* device_uuid);
  private:
  const std::string& _internal_device_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_uuid(const std::string& value);
  std::string* _internal_mutable_device_uuid();
  public:

  // int32 device_id = 1;
  void clear_device_id();
  int32_t device_id() const;
  void set_device_id(int32_t value);
  private:
  int32_t _internal_device_id() const;
  void _internal_set_device_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.DeviceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_uuid_;
    int32_t device_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class WgConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.WgConfigRequest) */ {
 public:
  inline WgConfigRequest() : WgConfigRequest(nullptr) {}
  ~WgConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR WgConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WgConfigRequest(const WgConfigRequest& from);
  WgConfigRequest(WgConfigRequest&& from) noexcept
    : WgConfigRequest() {
    *this = ::std::move(from);
  }

  inline WgConfigRequest& operator=(const WgConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WgConfigRequest& operator=(WgConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WgConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WgConfigRequest* internal_default_instance() {
    return reinterpret_cast<const WgConfigRequest*>(
               &_WgConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WgConfigRequest& a, WgConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WgConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WgConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WgConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WgConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WgConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WgConfigRequest& from) {
    WgConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WgConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.WgConfigRequest";
  }
  protected:
  explicit WgConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunnelsFieldNumber = 5,
    kUserInfoFieldNumber = 3,
    kDeviceInfoFieldNumber = 4,
    kBoxIdFieldNumber = 2,
    kOptFieldNumber = 1,
  };
  // repeated .hybrid_scope.WgTunnelConfig tunnels = 5;
  int tunnels_size() const;
  private:
  int _internal_tunnels_size() const;
  public:
  void clear_tunnels();
  ::hybrid_scope::WgTunnelConfig* mutable_tunnels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hybrid_scope::WgTunnelConfig >*
      mutable_tunnels();
  private:
  const ::hybrid_scope::WgTunnelConfig& _internal_tunnels(int index) const;
  ::hybrid_scope::WgTunnelConfig* _internal_add_tunnels();
  public:
  const ::hybrid_scope::WgTunnelConfig& tunnels(int index) const;
  ::hybrid_scope::WgTunnelConfig* add_tunnels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hybrid_scope::WgTunnelConfig >&
      tunnels() const;

  // .hybrid_scope.UserInfo user_info = 3;
  bool has_user_info() const;
  private:
  bool _internal_has_user_info() const;
  public:
  void clear_user_info();
  const ::hybrid_scope::UserInfo& user_info() const;
  PROTOBUF_NODISCARD ::hybrid_scope::UserInfo* release_user_info();
  ::hybrid_scope::UserInfo* mutable_user_info();
  void set_allocated_user_info(::hybrid_scope::UserInfo* user_info);
  private:
  const ::hybrid_scope::UserInfo& _internal_user_info() const;
  ::hybrid_scope::UserInfo* _internal_mutable_user_info();
  public:
  void unsafe_arena_set_allocated_user_info(
      ::hybrid_scope::UserInfo* user_info);
  ::hybrid_scope::UserInfo* unsafe_arena_release_user_info();

  // .hybrid_scope.DeviceInfo device_info = 4;
  bool has_device_info() const;
  private:
  bool _internal_has_device_info() const;
  public:
  void clear_device_info();
  const ::hybrid_scope::DeviceInfo& device_info() const;
  PROTOBUF_NODISCARD ::hybrid_scope::DeviceInfo* release_device_info();
  ::hybrid_scope::DeviceInfo* mutable_device_info();
  void set_allocated_device_info(::hybrid_scope::DeviceInfo* device_info);
  private:
  const ::hybrid_scope::DeviceInfo& _internal_device_info() const;
  ::hybrid_scope::DeviceInfo* _internal_mutable_device_info();
  public:
  void unsafe_arena_set_allocated_device_info(
      ::hybrid_scope::DeviceInfo* device_info);
  ::hybrid_scope::DeviceInfo* unsafe_arena_release_device_info();

  // uint64 box_id = 2;
  void clear_box_id();
  uint64_t box_id() const;
  void set_box_id(uint64_t value);
  private:
  uint64_t _internal_box_id() const;
  void _internal_set_box_id(uint64_t value);
  public:

  // int32 opt = 1;
  void clear_opt();
  int32_t opt() const;
  void set_opt(int32_t value);
  private:
  int32_t _internal_opt() const;
  void _internal_set_opt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.WgConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hybrid_scope::WgTunnelConfig > tunnels_;
    ::hybrid_scope::UserInfo* user_info_;
    ::hybrid_scope::DeviceInfo* device_info_;
    uint64_t box_id_;
    int32_t opt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class WgStartupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.WgStartupRequest) */ {
 public:
  inline WgStartupRequest() : WgStartupRequest(nullptr) {}
  ~WgStartupRequest() override;
  explicit PROTOBUF_CONSTEXPR WgStartupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WgStartupRequest(const WgStartupRequest& from);
  WgStartupRequest(WgStartupRequest&& from) noexcept
    : WgStartupRequest() {
    *this = ::std::move(from);
  }

  inline WgStartupRequest& operator=(const WgStartupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WgStartupRequest& operator=(WgStartupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WgStartupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WgStartupRequest* internal_default_instance() {
    return reinterpret_cast<const WgStartupRequest*>(
               &_WgStartupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(WgStartupRequest& a, WgStartupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WgStartupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WgStartupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WgStartupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WgStartupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WgStartupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WgStartupRequest& from) {
    WgStartupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WgStartupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.WgStartupRequest";
  }
  protected:
  explicit WgStartupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.WgStartupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class WgShutdownRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.WgShutdownRequest) */ {
 public:
  inline WgShutdownRequest() : WgShutdownRequest(nullptr) {}
  ~WgShutdownRequest() override;
  explicit PROTOBUF_CONSTEXPR WgShutdownRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WgShutdownRequest(const WgShutdownRequest& from);
  WgShutdownRequest(WgShutdownRequest&& from) noexcept
    : WgShutdownRequest() {
    *this = ::std::move(from);
  }

  inline WgShutdownRequest& operator=(const WgShutdownRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WgShutdownRequest& operator=(WgShutdownRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WgShutdownRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WgShutdownRequest* internal_default_instance() {
    return reinterpret_cast<const WgShutdownRequest*>(
               &_WgShutdownRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(WgShutdownRequest& a, WgShutdownRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WgShutdownRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WgShutdownRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WgShutdownRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WgShutdownRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WgShutdownRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WgShutdownRequest& from) {
    WgShutdownRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WgShutdownRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.WgShutdownRequest";
  }
  protected:
  explicit WgShutdownRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.WgShutdownRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class WgExecRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.WgExecRequest) */ {
 public:
  inline WgExecRequest() : WgExecRequest(nullptr) {}
  ~WgExecRequest() override;
  explicit PROTOBUF_CONSTEXPR WgExecRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WgExecRequest(const WgExecRequest& from);
  WgExecRequest(WgExecRequest&& from) noexcept
    : WgExecRequest() {
    *this = ::std::move(from);
  }

  inline WgExecRequest& operator=(const WgExecRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WgExecRequest& operator=(WgExecRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WgExecRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WgExecRequest* internal_default_instance() {
    return reinterpret_cast<const WgExecRequest*>(
               &_WgExecRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(WgExecRequest& a, WgExecRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WgExecRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WgExecRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WgExecRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WgExecRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WgExecRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WgExecRequest& from) {
    WgExecRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WgExecRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.WgExecRequest";
  }
  protected:
  explicit WgExecRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdlineFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string cmdline = 2;
  void clear_cmdline();
  const std::string& cmdline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cmdline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cmdline();
  PROTOBUF_NODISCARD std::string* release_cmdline();
  void set_allocated_cmdline(std::string* cmdline);
  private:
  const std::string& _internal_cmdline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmdline(const std::string& value);
  std::string* _internal_mutable_cmdline();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.WgExecRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmdline_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class WgKeypair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.WgKeypair) */ {
 public:
  inline WgKeypair() : WgKeypair(nullptr) {}
  ~WgKeypair() override;
  explicit PROTOBUF_CONSTEXPR WgKeypair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WgKeypair(const WgKeypair& from);
  WgKeypair(WgKeypair&& from) noexcept
    : WgKeypair() {
    *this = ::std::move(from);
  }

  inline WgKeypair& operator=(const WgKeypair& from) {
    CopyFrom(from);
    return *this;
  }
  inline WgKeypair& operator=(WgKeypair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WgKeypair& default_instance() {
    return *internal_default_instance();
  }
  static inline const WgKeypair* internal_default_instance() {
    return reinterpret_cast<const WgKeypair*>(
               &_WgKeypair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(WgKeypair& a, WgKeypair& b) {
    a.Swap(&b);
  }
  inline void Swap(WgKeypair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WgKeypair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WgKeypair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WgKeypair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WgKeypair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WgKeypair& from) {
    WgKeypair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WgKeypair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.WgKeypair";
  }
  protected:
  explicit WgKeypair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kPrivateKeyFieldNumber = 2,
  };
  // string public_key = 1;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // string private_key = 2;
  void clear_private_key();
  const std::string& private_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_key();
  PROTOBUF_NODISCARD std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.WgKeypair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class WgPublicKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.WgPublicKey) */ {
 public:
  inline WgPublicKey() : WgPublicKey(nullptr) {}
  ~WgPublicKey() override;
  explicit PROTOBUF_CONSTEXPR WgPublicKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WgPublicKey(const WgPublicKey& from);
  WgPublicKey(WgPublicKey&& from) noexcept
    : WgPublicKey() {
    *this = ::std::move(from);
  }

  inline WgPublicKey& operator=(const WgPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline WgPublicKey& operator=(WgPublicKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WgPublicKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const WgPublicKey* internal_default_instance() {
    return reinterpret_cast<const WgPublicKey*>(
               &_WgPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(WgPublicKey& a, WgPublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(WgPublicKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WgPublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WgPublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WgPublicKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WgPublicKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WgPublicKey& from) {
    WgPublicKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WgPublicKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.WgPublicKey";
  }
  protected:
  explicit WgPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.WgPublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// -------------------------------------------------------------------

class WgPrivateKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hybrid_scope.WgPrivateKey) */ {
 public:
  inline WgPrivateKey() : WgPrivateKey(nullptr) {}
  ~WgPrivateKey() override;
  explicit PROTOBUF_CONSTEXPR WgPrivateKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WgPrivateKey(const WgPrivateKey& from);
  WgPrivateKey(WgPrivateKey&& from) noexcept
    : WgPrivateKey() {
    *this = ::std::move(from);
  }

  inline WgPrivateKey& operator=(const WgPrivateKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline WgPrivateKey& operator=(WgPrivateKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WgPrivateKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const WgPrivateKey* internal_default_instance() {
    return reinterpret_cast<const WgPrivateKey*>(
               &_WgPrivateKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(WgPrivateKey& a, WgPrivateKey& b) {
    a.Swap(&b);
  }
  inline void Swap(WgPrivateKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WgPrivateKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WgPrivateKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WgPrivateKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WgPrivateKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WgPrivateKey& from) {
    WgPrivateKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WgPrivateKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hybrid_scope.WgPrivateKey";
  }
  protected:
  explicit WgPrivateKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:hybrid_scope.WgPrivateKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hybrid_5fscope_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EchoRequest

// string name = 1;
inline void EchoRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& EchoRequest::name() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.EchoRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EchoRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.EchoRequest.name)
}
inline std::string* EchoRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.EchoRequest.name)
  return _s;
}
inline const std::string& EchoRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void EchoRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* EchoRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* EchoRequest::release_name() {
  // @@protoc_insertion_point(field_release:hybrid_scope.EchoRequest.name)
  return _impl_.name_.Release();
}
inline void EchoRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.EchoRequest.name)
}

// -------------------------------------------------------------------

// EchoResponse

// string message = 1;
inline void EchoResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& EchoResponse::message() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.EchoResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EchoResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.EchoResponse.message)
}
inline std::string* EchoResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.EchoResponse.message)
  return _s;
}
inline const std::string& EchoResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void EchoResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* EchoResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* EchoResponse::release_message() {
  // @@protoc_insertion_point(field_release:hybrid_scope.EchoResponse.message)
  return _impl_.message_.Release();
}
inline void EchoResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.EchoResponse.message)
}

// -------------------------------------------------------------------

// Void

// -------------------------------------------------------------------

// RpcResult

// int32 code = 1;
inline void RpcResult::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t RpcResult::_internal_code() const {
  return _impl_.code_;
}
inline int32_t RpcResult::code() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.RpcResult.code)
  return _internal_code();
}
inline void RpcResult::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void RpcResult::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.RpcResult.code)
}

// string message = 2;
inline void RpcResult::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RpcResult::message() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.RpcResult.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RpcResult::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.RpcResult.message)
}
inline std::string* RpcResult::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.RpcResult.message)
  return _s;
}
inline const std::string& RpcResult::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RpcResult::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcResult::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RpcResult::release_message() {
  // @@protoc_insertion_point(field_release:hybrid_scope.RpcResult.message)
  return _impl_.message_.Release();
}
inline void RpcResult::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.RpcResult.message)
}

// -------------------------------------------------------------------

// WgPeerInfo

// string pubkey = 1;
inline void WgPeerInfo::clear_pubkey() {
  _impl_.pubkey_.ClearToEmpty();
}
inline const std::string& WgPeerInfo::pubkey() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgPeerInfo.pubkey)
  return _internal_pubkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgPeerInfo::set_pubkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pubkey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgPeerInfo.pubkey)
}
inline std::string* WgPeerInfo::mutable_pubkey() {
  std::string* _s = _internal_mutable_pubkey();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgPeerInfo.pubkey)
  return _s;
}
inline const std::string& WgPeerInfo::_internal_pubkey() const {
  return _impl_.pubkey_.Get();
}
inline void WgPeerInfo::_internal_set_pubkey(const std::string& value) {
  
  _impl_.pubkey_.Set(value, GetArenaForAllocation());
}
inline std::string* WgPeerInfo::_internal_mutable_pubkey() {
  
  return _impl_.pubkey_.Mutable(GetArenaForAllocation());
}
inline std::string* WgPeerInfo::release_pubkey() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgPeerInfo.pubkey)
  return _impl_.pubkey_.Release();
}
inline void WgPeerInfo::set_allocated_pubkey(std::string* pubkey) {
  if (pubkey != nullptr) {
    
  } else {
    
  }
  _impl_.pubkey_.SetAllocated(pubkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pubkey_.IsDefault()) {
    _impl_.pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgPeerInfo.pubkey)
}

// string prikey = 2;
inline void WgPeerInfo::clear_prikey() {
  _impl_.prikey_.ClearToEmpty();
}
inline const std::string& WgPeerInfo::prikey() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgPeerInfo.prikey)
  return _internal_prikey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgPeerInfo::set_prikey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prikey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgPeerInfo.prikey)
}
inline std::string* WgPeerInfo::mutable_prikey() {
  std::string* _s = _internal_mutable_prikey();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgPeerInfo.prikey)
  return _s;
}
inline const std::string& WgPeerInfo::_internal_prikey() const {
  return _impl_.prikey_.Get();
}
inline void WgPeerInfo::_internal_set_prikey(const std::string& value) {
  
  _impl_.prikey_.Set(value, GetArenaForAllocation());
}
inline std::string* WgPeerInfo::_internal_mutable_prikey() {
  
  return _impl_.prikey_.Mutable(GetArenaForAllocation());
}
inline std::string* WgPeerInfo::release_prikey() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgPeerInfo.prikey)
  return _impl_.prikey_.Release();
}
inline void WgPeerInfo::set_allocated_prikey(std::string* prikey) {
  if (prikey != nullptr) {
    
  } else {
    
  }
  _impl_.prikey_.SetAllocated(prikey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prikey_.IsDefault()) {
    _impl_.prikey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgPeerInfo.prikey)
}

// string ipv4 = 3;
inline void WgPeerInfo::clear_ipv4() {
  _impl_.ipv4_.ClearToEmpty();
}
inline const std::string& WgPeerInfo::ipv4() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgPeerInfo.ipv4)
  return _internal_ipv4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgPeerInfo::set_ipv4(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ipv4_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgPeerInfo.ipv4)
}
inline std::string* WgPeerInfo::mutable_ipv4() {
  std::string* _s = _internal_mutable_ipv4();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgPeerInfo.ipv4)
  return _s;
}
inline const std::string& WgPeerInfo::_internal_ipv4() const {
  return _impl_.ipv4_.Get();
}
inline void WgPeerInfo::_internal_set_ipv4(const std::string& value) {
  
  _impl_.ipv4_.Set(value, GetArenaForAllocation());
}
inline std::string* WgPeerInfo::_internal_mutable_ipv4() {
  
  return _impl_.ipv4_.Mutable(GetArenaForAllocation());
}
inline std::string* WgPeerInfo::release_ipv4() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgPeerInfo.ipv4)
  return _impl_.ipv4_.Release();
}
inline void WgPeerInfo::set_allocated_ipv4(std::string* ipv4) {
  if (ipv4 != nullptr) {
    
  } else {
    
  }
  _impl_.ipv4_.SetAllocated(ipv4, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ipv4_.IsDefault()) {
    _impl_.ipv4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgPeerInfo.ipv4)
}

// string ipv6 = 4;
inline void WgPeerInfo::clear_ipv6() {
  _impl_.ipv6_.ClearToEmpty();
}
inline const std::string& WgPeerInfo::ipv6() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgPeerInfo.ipv6)
  return _internal_ipv6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgPeerInfo::set_ipv6(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ipv6_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgPeerInfo.ipv6)
}
inline std::string* WgPeerInfo::mutable_ipv6() {
  std::string* _s = _internal_mutable_ipv6();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgPeerInfo.ipv6)
  return _s;
}
inline const std::string& WgPeerInfo::_internal_ipv6() const {
  return _impl_.ipv6_.Get();
}
inline void WgPeerInfo::_internal_set_ipv6(const std::string& value) {
  
  _impl_.ipv6_.Set(value, GetArenaForAllocation());
}
inline std::string* WgPeerInfo::_internal_mutable_ipv6() {
  
  return _impl_.ipv6_.Mutable(GetArenaForAllocation());
}
inline std::string* WgPeerInfo::release_ipv6() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgPeerInfo.ipv6)
  return _impl_.ipv6_.Release();
}
inline void WgPeerInfo::set_allocated_ipv6(std::string* ipv6) {
  if (ipv6 != nullptr) {
    
  } else {
    
  }
  _impl_.ipv6_.SetAllocated(ipv6, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ipv6_.IsDefault()) {
    _impl_.ipv6_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgPeerInfo.ipv6)
}

// uint32 port = 5;
inline void WgPeerInfo::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t WgPeerInfo::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t WgPeerInfo::port() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgPeerInfo.port)
  return _internal_port();
}
inline void WgPeerInfo::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void WgPeerInfo::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgPeerInfo.port)
}

// string mask = 6;
inline void WgPeerInfo::clear_mask() {
  _impl_.mask_.ClearToEmpty();
}
inline const std::string& WgPeerInfo::mask() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgPeerInfo.mask)
  return _internal_mask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgPeerInfo::set_mask(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mask_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgPeerInfo.mask)
}
inline std::string* WgPeerInfo::mutable_mask() {
  std::string* _s = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgPeerInfo.mask)
  return _s;
}
inline const std::string& WgPeerInfo::_internal_mask() const {
  return _impl_.mask_.Get();
}
inline void WgPeerInfo::_internal_set_mask(const std::string& value) {
  
  _impl_.mask_.Set(value, GetArenaForAllocation());
}
inline std::string* WgPeerInfo::_internal_mutable_mask() {
  
  return _impl_.mask_.Mutable(GetArenaForAllocation());
}
inline std::string* WgPeerInfo::release_mask() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgPeerInfo.mask)
  return _impl_.mask_.Release();
}
inline void WgPeerInfo::set_allocated_mask(std::string* mask) {
  if (mask != nullptr) {
    
  } else {
    
  }
  _impl_.mask_.SetAllocated(mask, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mask_.IsDefault()) {
    _impl_.mask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgPeerInfo.mask)
}

// -------------------------------------------------------------------

// WgGatewayConfig

// int32 id = 1;
inline void WgGatewayConfig::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t WgGatewayConfig::_internal_id() const {
  return _impl_.id_;
}
inline int32_t WgGatewayConfig::id() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.id)
  return _internal_id();
}
inline void WgGatewayConfig::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void WgGatewayConfig::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.id)
}

// string ip = 2;
inline void WgGatewayConfig::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& WgGatewayConfig::ip() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgGatewayConfig::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.ip)
}
inline std::string* WgGatewayConfig::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgGatewayConfig.ip)
  return _s;
}
inline const std::string& WgGatewayConfig::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void WgGatewayConfig::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::release_ip() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgGatewayConfig.ip)
  return _impl_.ip_.Release();
}
inline void WgGatewayConfig::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgGatewayConfig.ip)
}

// uint32 wireguard_port = 3;
inline void WgGatewayConfig::clear_wireguard_port() {
  _impl_.wireguard_port_ = 0u;
}
inline uint32_t WgGatewayConfig::_internal_wireguard_port() const {
  return _impl_.wireguard_port_;
}
inline uint32_t WgGatewayConfig::wireguard_port() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.wireguard_port)
  return _internal_wireguard_port();
}
inline void WgGatewayConfig::_internal_set_wireguard_port(uint32_t value) {
  
  _impl_.wireguard_port_ = value;
}
inline void WgGatewayConfig::set_wireguard_port(uint32_t value) {
  _internal_set_wireguard_port(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.wireguard_port)
}

// string name = 4;
inline void WgGatewayConfig::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& WgGatewayConfig::name() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgGatewayConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.name)
}
inline std::string* WgGatewayConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgGatewayConfig.name)
  return _s;
}
inline const std::string& WgGatewayConfig::_internal_name() const {
  return _impl_.name_.Get();
}
inline void WgGatewayConfig::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::release_name() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgGatewayConfig.name)
  return _impl_.name_.Release();
}
inline void WgGatewayConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgGatewayConfig.name)
}

// uint32 gateway_id = 5;
inline void WgGatewayConfig::clear_gateway_id() {
  _impl_.gateway_id_ = 0u;
}
inline uint32_t WgGatewayConfig::_internal_gateway_id() const {
  return _impl_.gateway_id_;
}
inline uint32_t WgGatewayConfig::gateway_id() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.gateway_id)
  return _internal_gateway_id();
}
inline void WgGatewayConfig::_internal_set_gateway_id(uint32_t value) {
  
  _impl_.gateway_id_ = value;
}
inline void WgGatewayConfig::set_gateway_id(uint32_t value) {
  _internal_set_gateway_id(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.gateway_id)
}

// string gateway_uuid = 6;
inline void WgGatewayConfig::clear_gateway_uuid() {
  _impl_.gateway_uuid_.ClearToEmpty();
}
inline const std::string& WgGatewayConfig::gateway_uuid() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.gateway_uuid)
  return _internal_gateway_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgGatewayConfig::set_gateway_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gateway_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.gateway_uuid)
}
inline std::string* WgGatewayConfig::mutable_gateway_uuid() {
  std::string* _s = _internal_mutable_gateway_uuid();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgGatewayConfig.gateway_uuid)
  return _s;
}
inline const std::string& WgGatewayConfig::_internal_gateway_uuid() const {
  return _impl_.gateway_uuid_.Get();
}
inline void WgGatewayConfig::_internal_set_gateway_uuid(const std::string& value) {
  
  _impl_.gateway_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::_internal_mutable_gateway_uuid() {
  
  return _impl_.gateway_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::release_gateway_uuid() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgGatewayConfig.gateway_uuid)
  return _impl_.gateway_uuid_.Release();
}
inline void WgGatewayConfig::set_allocated_gateway_uuid(std::string* gateway_uuid) {
  if (gateway_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.gateway_uuid_.SetAllocated(gateway_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gateway_uuid_.IsDefault()) {
    _impl_.gateway_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgGatewayConfig.gateway_uuid)
}

// string gateway_public_key = 7;
inline void WgGatewayConfig::clear_gateway_public_key() {
  _impl_.gateway_public_key_.ClearToEmpty();
}
inline const std::string& WgGatewayConfig::gateway_public_key() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.gateway_public_key)
  return _internal_gateway_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgGatewayConfig::set_gateway_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gateway_public_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.gateway_public_key)
}
inline std::string* WgGatewayConfig::mutable_gateway_public_key() {
  std::string* _s = _internal_mutable_gateway_public_key();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgGatewayConfig.gateway_public_key)
  return _s;
}
inline const std::string& WgGatewayConfig::_internal_gateway_public_key() const {
  return _impl_.gateway_public_key_.Get();
}
inline void WgGatewayConfig::_internal_set_gateway_public_key(const std::string& value) {
  
  _impl_.gateway_public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::_internal_mutable_gateway_public_key() {
  
  return _impl_.gateway_public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::release_gateway_public_key() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgGatewayConfig.gateway_public_key)
  return _impl_.gateway_public_key_.Release();
}
inline void WgGatewayConfig::set_allocated_gateway_public_key(std::string* gateway_public_key) {
  if (gateway_public_key != nullptr) {
    
  } else {
    
  }
  _impl_.gateway_public_key_.SetAllocated(gateway_public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gateway_public_key_.IsDefault()) {
    _impl_.gateway_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgGatewayConfig.gateway_public_key)
}

// uint64 obf_key = 8;
inline void WgGatewayConfig::clear_obf_key() {
  _impl_.obf_key_ = uint64_t{0u};
}
inline uint64_t WgGatewayConfig::_internal_obf_key() const {
  return _impl_.obf_key_;
}
inline uint64_t WgGatewayConfig::obf_key() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.obf_key)
  return _internal_obf_key();
}
inline void WgGatewayConfig::_internal_set_obf_key(uint64_t value) {
  
  _impl_.obf_key_ = value;
}
inline void WgGatewayConfig::set_obf_key(uint64_t value) {
  _internal_set_obf_key(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.obf_key)
}

// uint32 keep_alive = 9;
inline void WgGatewayConfig::clear_keep_alive() {
  _impl_.keep_alive_ = 0u;
}
inline uint32_t WgGatewayConfig::_internal_keep_alive() const {
  return _impl_.keep_alive_;
}
inline uint32_t WgGatewayConfig::keep_alive() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.keep_alive)
  return _internal_keep_alive();
}
inline void WgGatewayConfig::_internal_set_keep_alive(uint32_t value) {
  
  _impl_.keep_alive_ = value;
}
inline void WgGatewayConfig::set_keep_alive(uint32_t value) {
  _internal_set_keep_alive(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.keep_alive)
}

// string transport = 10;
inline void WgGatewayConfig::clear_transport() {
  _impl_.transport_.ClearToEmpty();
}
inline const std::string& WgGatewayConfig::transport() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.transport)
  return _internal_transport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgGatewayConfig::set_transport(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.transport)
}
inline std::string* WgGatewayConfig::mutable_transport() {
  std::string* _s = _internal_mutable_transport();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgGatewayConfig.transport)
  return _s;
}
inline const std::string& WgGatewayConfig::_internal_transport() const {
  return _impl_.transport_.Get();
}
inline void WgGatewayConfig::_internal_set_transport(const std::string& value) {
  
  _impl_.transport_.Set(value, GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::_internal_mutable_transport() {
  
  return _impl_.transport_.Mutable(GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::release_transport() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgGatewayConfig.transport)
  return _impl_.transport_.Release();
}
inline void WgGatewayConfig::set_allocated_transport(std::string* transport) {
  if (transport != nullptr) {
    
  } else {
    
  }
  _impl_.transport_.SetAllocated(transport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transport_.IsDefault()) {
    _impl_.transport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgGatewayConfig.transport)
}

// uint32 mode = 11;
inline void WgGatewayConfig::clear_mode() {
  _impl_.mode_ = 0u;
}
inline uint32_t WgGatewayConfig::_internal_mode() const {
  return _impl_.mode_;
}
inline uint32_t WgGatewayConfig::mode() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.mode)
  return _internal_mode();
}
inline void WgGatewayConfig::_internal_set_mode(uint32_t value) {
  
  _impl_.mode_ = value;
}
inline void WgGatewayConfig::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.mode)
}

// uint32 encrypt_mode = 12;
inline void WgGatewayConfig::clear_encrypt_mode() {
  _impl_.encrypt_mode_ = 0u;
}
inline uint32_t WgGatewayConfig::_internal_encrypt_mode() const {
  return _impl_.encrypt_mode_;
}
inline uint32_t WgGatewayConfig::encrypt_mode() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.encrypt_mode)
  return _internal_encrypt_mode();
}
inline void WgGatewayConfig::_internal_set_encrypt_mode(uint32_t value) {
  
  _impl_.encrypt_mode_ = value;
}
inline void WgGatewayConfig::set_encrypt_mode(uint32_t value) {
  _internal_set_encrypt_mode(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.encrypt_mode)
}

// string virtual_ipv4 = 13;
inline void WgGatewayConfig::clear_virtual_ipv4() {
  _impl_.virtual_ipv4_.ClearToEmpty();
}
inline const std::string& WgGatewayConfig::virtual_ipv4() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.virtual_ipv4)
  return _internal_virtual_ipv4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgGatewayConfig::set_virtual_ipv4(ArgT0&& arg0, ArgT... args) {
 
 _impl_.virtual_ipv4_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.virtual_ipv4)
}
inline std::string* WgGatewayConfig::mutable_virtual_ipv4() {
  std::string* _s = _internal_mutable_virtual_ipv4();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgGatewayConfig.virtual_ipv4)
  return _s;
}
inline const std::string& WgGatewayConfig::_internal_virtual_ipv4() const {
  return _impl_.virtual_ipv4_.Get();
}
inline void WgGatewayConfig::_internal_set_virtual_ipv4(const std::string& value) {
  
  _impl_.virtual_ipv4_.Set(value, GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::_internal_mutable_virtual_ipv4() {
  
  return _impl_.virtual_ipv4_.Mutable(GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::release_virtual_ipv4() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgGatewayConfig.virtual_ipv4)
  return _impl_.virtual_ipv4_.Release();
}
inline void WgGatewayConfig::set_allocated_virtual_ipv4(std::string* virtual_ipv4) {
  if (virtual_ipv4 != nullptr) {
    
  } else {
    
  }
  _impl_.virtual_ipv4_.SetAllocated(virtual_ipv4, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.virtual_ipv4_.IsDefault()) {
    _impl_.virtual_ipv4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgGatewayConfig.virtual_ipv4)
}

// string virtual_ipv6 = 14;
inline void WgGatewayConfig::clear_virtual_ipv6() {
  _impl_.virtual_ipv6_.ClearToEmpty();
}
inline const std::string& WgGatewayConfig::virtual_ipv6() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.virtual_ipv6)
  return _internal_virtual_ipv6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgGatewayConfig::set_virtual_ipv6(ArgT0&& arg0, ArgT... args) {
 
 _impl_.virtual_ipv6_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.virtual_ipv6)
}
inline std::string* WgGatewayConfig::mutable_virtual_ipv6() {
  std::string* _s = _internal_mutable_virtual_ipv6();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgGatewayConfig.virtual_ipv6)
  return _s;
}
inline const std::string& WgGatewayConfig::_internal_virtual_ipv6() const {
  return _impl_.virtual_ipv6_.Get();
}
inline void WgGatewayConfig::_internal_set_virtual_ipv6(const std::string& value) {
  
  _impl_.virtual_ipv6_.Set(value, GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::_internal_mutable_virtual_ipv6() {
  
  return _impl_.virtual_ipv6_.Mutable(GetArenaForAllocation());
}
inline std::string* WgGatewayConfig::release_virtual_ipv6() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgGatewayConfig.virtual_ipv6)
  return _impl_.virtual_ipv6_.Release();
}
inline void WgGatewayConfig::set_allocated_virtual_ipv6(std::string* virtual_ipv6) {
  if (virtual_ipv6 != nullptr) {
    
  } else {
    
  }
  _impl_.virtual_ipv6_.SetAllocated(virtual_ipv6, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.virtual_ipv6_.IsDefault()) {
    _impl_.virtual_ipv6_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgGatewayConfig.virtual_ipv6)
}

// uint32 mtu = 15;
inline void WgGatewayConfig::clear_mtu() {
  _impl_.mtu_ = 0u;
}
inline uint32_t WgGatewayConfig::_internal_mtu() const {
  return _impl_.mtu_;
}
inline uint32_t WgGatewayConfig::mtu() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgGatewayConfig.mtu)
  return _internal_mtu();
}
inline void WgGatewayConfig::_internal_set_mtu(uint32_t value) {
  
  _impl_.mtu_ = value;
}
inline void WgGatewayConfig::set_mtu(uint32_t value) {
  _internal_set_mtu(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgGatewayConfig.mtu)
}

// -------------------------------------------------------------------

// WgTunnelConfig

// .hybrid_scope.WgPeerInfo peer_info = 1;
inline bool WgTunnelConfig::_internal_has_peer_info() const {
  return this != internal_default_instance() && _impl_.peer_info_ != nullptr;
}
inline bool WgTunnelConfig::has_peer_info() const {
  return _internal_has_peer_info();
}
inline void WgTunnelConfig::clear_peer_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.peer_info_ != nullptr) {
    delete _impl_.peer_info_;
  }
  _impl_.peer_info_ = nullptr;
}
inline const ::hybrid_scope::WgPeerInfo& WgTunnelConfig::_internal_peer_info() const {
  const ::hybrid_scope::WgPeerInfo* p = _impl_.peer_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::hybrid_scope::WgPeerInfo&>(
      ::hybrid_scope::_WgPeerInfo_default_instance_);
}
inline const ::hybrid_scope::WgPeerInfo& WgTunnelConfig::peer_info() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgTunnelConfig.peer_info)
  return _internal_peer_info();
}
inline void WgTunnelConfig::unsafe_arena_set_allocated_peer_info(
    ::hybrid_scope::WgPeerInfo* peer_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_info_);
  }
  _impl_.peer_info_ = peer_info;
  if (peer_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hybrid_scope.WgTunnelConfig.peer_info)
}
inline ::hybrid_scope::WgPeerInfo* WgTunnelConfig::release_peer_info() {
  
  ::hybrid_scope::WgPeerInfo* temp = _impl_.peer_info_;
  _impl_.peer_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hybrid_scope::WgPeerInfo* WgTunnelConfig::unsafe_arena_release_peer_info() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgTunnelConfig.peer_info)
  
  ::hybrid_scope::WgPeerInfo* temp = _impl_.peer_info_;
  _impl_.peer_info_ = nullptr;
  return temp;
}
inline ::hybrid_scope::WgPeerInfo* WgTunnelConfig::_internal_mutable_peer_info() {
  
  if (_impl_.peer_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::hybrid_scope::WgPeerInfo>(GetArenaForAllocation());
    _impl_.peer_info_ = p;
  }
  return _impl_.peer_info_;
}
inline ::hybrid_scope::WgPeerInfo* WgTunnelConfig::mutable_peer_info() {
  ::hybrid_scope::WgPeerInfo* _msg = _internal_mutable_peer_info();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgTunnelConfig.peer_info)
  return _msg;
}
inline void WgTunnelConfig::set_allocated_peer_info(::hybrid_scope::WgPeerInfo* peer_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.peer_info_;
  }
  if (peer_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(peer_info);
    if (message_arena != submessage_arena) {
      peer_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_info_ = peer_info;
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgTunnelConfig.peer_info)
}

// .hybrid_scope.WgGatewayConfig gateway_info = 2;
inline bool WgTunnelConfig::_internal_has_gateway_info() const {
  return this != internal_default_instance() && _impl_.gateway_info_ != nullptr;
}
inline bool WgTunnelConfig::has_gateway_info() const {
  return _internal_has_gateway_info();
}
inline void WgTunnelConfig::clear_gateway_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.gateway_info_ != nullptr) {
    delete _impl_.gateway_info_;
  }
  _impl_.gateway_info_ = nullptr;
}
inline const ::hybrid_scope::WgGatewayConfig& WgTunnelConfig::_internal_gateway_info() const {
  const ::hybrid_scope::WgGatewayConfig* p = _impl_.gateway_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::hybrid_scope::WgGatewayConfig&>(
      ::hybrid_scope::_WgGatewayConfig_default_instance_);
}
inline const ::hybrid_scope::WgGatewayConfig& WgTunnelConfig::gateway_info() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgTunnelConfig.gateway_info)
  return _internal_gateway_info();
}
inline void WgTunnelConfig::unsafe_arena_set_allocated_gateway_info(
    ::hybrid_scope::WgGatewayConfig* gateway_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gateway_info_);
  }
  _impl_.gateway_info_ = gateway_info;
  if (gateway_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hybrid_scope.WgTunnelConfig.gateway_info)
}
inline ::hybrid_scope::WgGatewayConfig* WgTunnelConfig::release_gateway_info() {
  
  ::hybrid_scope::WgGatewayConfig* temp = _impl_.gateway_info_;
  _impl_.gateway_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hybrid_scope::WgGatewayConfig* WgTunnelConfig::unsafe_arena_release_gateway_info() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgTunnelConfig.gateway_info)
  
  ::hybrid_scope::WgGatewayConfig* temp = _impl_.gateway_info_;
  _impl_.gateway_info_ = nullptr;
  return temp;
}
inline ::hybrid_scope::WgGatewayConfig* WgTunnelConfig::_internal_mutable_gateway_info() {
  
  if (_impl_.gateway_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::hybrid_scope::WgGatewayConfig>(GetArenaForAllocation());
    _impl_.gateway_info_ = p;
  }
  return _impl_.gateway_info_;
}
inline ::hybrid_scope::WgGatewayConfig* WgTunnelConfig::mutable_gateway_info() {
  ::hybrid_scope::WgGatewayConfig* _msg = _internal_mutable_gateway_info();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgTunnelConfig.gateway_info)
  return _msg;
}
inline void WgTunnelConfig::set_allocated_gateway_info(::hybrid_scope::WgGatewayConfig* gateway_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gateway_info_;
  }
  if (gateway_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gateway_info);
    if (message_arena != submessage_arena) {
      gateway_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gateway_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gateway_info_ = gateway_info;
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgTunnelConfig.gateway_info)
}

// -------------------------------------------------------------------

// UserInfo

// string token = 1;
inline void UserInfo::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& UserInfo::token() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.UserInfo.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.UserInfo.token)
}
inline std::string* UserInfo::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.UserInfo.token)
  return _s;
}
inline const std::string& UserInfo::_internal_token() const {
  return _impl_.token_.Get();
}
inline void UserInfo::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_token() {
  // @@protoc_insertion_point(field_release:hybrid_scope.UserInfo.token)
  return _impl_.token_.Release();
}
inline void UserInfo::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.UserInfo.token)
}

// uint64 user_id = 2;
inline void UserInfo::clear_user_id() {
  _impl_.user_id_ = uint64_t{0u};
}
inline uint64_t UserInfo::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint64_t UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.UserInfo.user_id)
  return _internal_user_id();
}
inline void UserInfo::_internal_set_user_id(uint64_t value) {
  
  _impl_.user_id_ = value;
}
inline void UserInfo::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.UserInfo.user_id)
}

// uint64 org_id = 3;
inline void UserInfo::clear_org_id() {
  _impl_.org_id_ = uint64_t{0u};
}
inline uint64_t UserInfo::_internal_org_id() const {
  return _impl_.org_id_;
}
inline uint64_t UserInfo::org_id() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.UserInfo.org_id)
  return _internal_org_id();
}
inline void UserInfo::_internal_set_org_id(uint64_t value) {
  
  _impl_.org_id_ = value;
}
inline void UserInfo::set_org_id(uint64_t value) {
  _internal_set_org_id(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.UserInfo.org_id)
}

// string tenant_name = 34;
inline void UserInfo::clear_tenant_name() {
  _impl_.tenant_name_.ClearToEmpty();
}
inline const std::string& UserInfo::tenant_name() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.UserInfo.tenant_name)
  return _internal_tenant_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_tenant_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tenant_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.UserInfo.tenant_name)
}
inline std::string* UserInfo::mutable_tenant_name() {
  std::string* _s = _internal_mutable_tenant_name();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.UserInfo.tenant_name)
  return _s;
}
inline const std::string& UserInfo::_internal_tenant_name() const {
  return _impl_.tenant_name_.Get();
}
inline void UserInfo::_internal_set_tenant_name(const std::string& value) {
  
  _impl_.tenant_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_tenant_name() {
  
  return _impl_.tenant_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_tenant_name() {
  // @@protoc_insertion_point(field_release:hybrid_scope.UserInfo.tenant_name)
  return _impl_.tenant_name_.Release();
}
inline void UserInfo::set_allocated_tenant_name(std::string* tenant_name) {
  if (tenant_name != nullptr) {
    
  } else {
    
  }
  _impl_.tenant_name_.SetAllocated(tenant_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tenant_name_.IsDefault()) {
    _impl_.tenant_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.UserInfo.tenant_name)
}

// -------------------------------------------------------------------

// DeviceInfo

// int32 device_id = 1;
inline void DeviceInfo::clear_device_id() {
  _impl_.device_id_ = 0;
}
inline int32_t DeviceInfo::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int32_t DeviceInfo::device_id() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.DeviceInfo.device_id)
  return _internal_device_id();
}
inline void DeviceInfo::_internal_set_device_id(int32_t value) {
  
  _impl_.device_id_ = value;
}
inline void DeviceInfo::set_device_id(int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.DeviceInfo.device_id)
}

// string device_uuid = 2;
inline void DeviceInfo::clear_device_uuid() {
  _impl_.device_uuid_.ClearToEmpty();
}
inline const std::string& DeviceInfo::device_uuid() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.DeviceInfo.device_uuid)
  return _internal_device_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_device_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.DeviceInfo.device_uuid)
}
inline std::string* DeviceInfo::mutable_device_uuid() {
  std::string* _s = _internal_mutable_device_uuid();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.DeviceInfo.device_uuid)
  return _s;
}
inline const std::string& DeviceInfo::_internal_device_uuid() const {
  return _impl_.device_uuid_.Get();
}
inline void DeviceInfo::_internal_set_device_uuid(const std::string& value) {
  
  _impl_.device_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_device_uuid() {
  
  return _impl_.device_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_device_uuid() {
  // @@protoc_insertion_point(field_release:hybrid_scope.DeviceInfo.device_uuid)
  return _impl_.device_uuid_.Release();
}
inline void DeviceInfo::set_allocated_device_uuid(std::string* device_uuid) {
  if (device_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.device_uuid_.SetAllocated(device_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_uuid_.IsDefault()) {
    _impl_.device_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.DeviceInfo.device_uuid)
}

// -------------------------------------------------------------------

// WgConfigRequest

// int32 opt = 1;
inline void WgConfigRequest::clear_opt() {
  _impl_.opt_ = 0;
}
inline int32_t WgConfigRequest::_internal_opt() const {
  return _impl_.opt_;
}
inline int32_t WgConfigRequest::opt() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgConfigRequest.opt)
  return _internal_opt();
}
inline void WgConfigRequest::_internal_set_opt(int32_t value) {
  
  _impl_.opt_ = value;
}
inline void WgConfigRequest::set_opt(int32_t value) {
  _internal_set_opt(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgConfigRequest.opt)
}

// uint64 box_id = 2;
inline void WgConfigRequest::clear_box_id() {
  _impl_.box_id_ = uint64_t{0u};
}
inline uint64_t WgConfigRequest::_internal_box_id() const {
  return _impl_.box_id_;
}
inline uint64_t WgConfigRequest::box_id() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgConfigRequest.box_id)
  return _internal_box_id();
}
inline void WgConfigRequest::_internal_set_box_id(uint64_t value) {
  
  _impl_.box_id_ = value;
}
inline void WgConfigRequest::set_box_id(uint64_t value) {
  _internal_set_box_id(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgConfigRequest.box_id)
}

// .hybrid_scope.UserInfo user_info = 3;
inline bool WgConfigRequest::_internal_has_user_info() const {
  return this != internal_default_instance() && _impl_.user_info_ != nullptr;
}
inline bool WgConfigRequest::has_user_info() const {
  return _internal_has_user_info();
}
inline void WgConfigRequest::clear_user_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_info_ != nullptr) {
    delete _impl_.user_info_;
  }
  _impl_.user_info_ = nullptr;
}
inline const ::hybrid_scope::UserInfo& WgConfigRequest::_internal_user_info() const {
  const ::hybrid_scope::UserInfo* p = _impl_.user_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::hybrid_scope::UserInfo&>(
      ::hybrid_scope::_UserInfo_default_instance_);
}
inline const ::hybrid_scope::UserInfo& WgConfigRequest::user_info() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgConfigRequest.user_info)
  return _internal_user_info();
}
inline void WgConfigRequest::unsafe_arena_set_allocated_user_info(
    ::hybrid_scope::UserInfo* user_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_info_);
  }
  _impl_.user_info_ = user_info;
  if (user_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hybrid_scope.WgConfigRequest.user_info)
}
inline ::hybrid_scope::UserInfo* WgConfigRequest::release_user_info() {
  
  ::hybrid_scope::UserInfo* temp = _impl_.user_info_;
  _impl_.user_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hybrid_scope::UserInfo* WgConfigRequest::unsafe_arena_release_user_info() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgConfigRequest.user_info)
  
  ::hybrid_scope::UserInfo* temp = _impl_.user_info_;
  _impl_.user_info_ = nullptr;
  return temp;
}
inline ::hybrid_scope::UserInfo* WgConfigRequest::_internal_mutable_user_info() {
  
  if (_impl_.user_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::hybrid_scope::UserInfo>(GetArenaForAllocation());
    _impl_.user_info_ = p;
  }
  return _impl_.user_info_;
}
inline ::hybrid_scope::UserInfo* WgConfigRequest::mutable_user_info() {
  ::hybrid_scope::UserInfo* _msg = _internal_mutable_user_info();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgConfigRequest.user_info)
  return _msg;
}
inline void WgConfigRequest::set_allocated_user_info(::hybrid_scope::UserInfo* user_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_info_;
  }
  if (user_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_info);
    if (message_arena != submessage_arena) {
      user_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_info_ = user_info;
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgConfigRequest.user_info)
}

// .hybrid_scope.DeviceInfo device_info = 4;
inline bool WgConfigRequest::_internal_has_device_info() const {
  return this != internal_default_instance() && _impl_.device_info_ != nullptr;
}
inline bool WgConfigRequest::has_device_info() const {
  return _internal_has_device_info();
}
inline void WgConfigRequest::clear_device_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.device_info_ != nullptr) {
    delete _impl_.device_info_;
  }
  _impl_.device_info_ = nullptr;
}
inline const ::hybrid_scope::DeviceInfo& WgConfigRequest::_internal_device_info() const {
  const ::hybrid_scope::DeviceInfo* p = _impl_.device_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::hybrid_scope::DeviceInfo&>(
      ::hybrid_scope::_DeviceInfo_default_instance_);
}
inline const ::hybrid_scope::DeviceInfo& WgConfigRequest::device_info() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgConfigRequest.device_info)
  return _internal_device_info();
}
inline void WgConfigRequest::unsafe_arena_set_allocated_device_info(
    ::hybrid_scope::DeviceInfo* device_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_info_);
  }
  _impl_.device_info_ = device_info;
  if (device_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hybrid_scope.WgConfigRequest.device_info)
}
inline ::hybrid_scope::DeviceInfo* WgConfigRequest::release_device_info() {
  
  ::hybrid_scope::DeviceInfo* temp = _impl_.device_info_;
  _impl_.device_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hybrid_scope::DeviceInfo* WgConfigRequest::unsafe_arena_release_device_info() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgConfigRequest.device_info)
  
  ::hybrid_scope::DeviceInfo* temp = _impl_.device_info_;
  _impl_.device_info_ = nullptr;
  return temp;
}
inline ::hybrid_scope::DeviceInfo* WgConfigRequest::_internal_mutable_device_info() {
  
  if (_impl_.device_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::hybrid_scope::DeviceInfo>(GetArenaForAllocation());
    _impl_.device_info_ = p;
  }
  return _impl_.device_info_;
}
inline ::hybrid_scope::DeviceInfo* WgConfigRequest::mutable_device_info() {
  ::hybrid_scope::DeviceInfo* _msg = _internal_mutable_device_info();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgConfigRequest.device_info)
  return _msg;
}
inline void WgConfigRequest::set_allocated_device_info(::hybrid_scope::DeviceInfo* device_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_info_;
  }
  if (device_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_info);
    if (message_arena != submessage_arena) {
      device_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_info_ = device_info;
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgConfigRequest.device_info)
}

// repeated .hybrid_scope.WgTunnelConfig tunnels = 5;
inline int WgConfigRequest::_internal_tunnels_size() const {
  return _impl_.tunnels_.size();
}
inline int WgConfigRequest::tunnels_size() const {
  return _internal_tunnels_size();
}
inline void WgConfigRequest::clear_tunnels() {
  _impl_.tunnels_.Clear();
}
inline ::hybrid_scope::WgTunnelConfig* WgConfigRequest::mutable_tunnels(int index) {
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgConfigRequest.tunnels)
  return _impl_.tunnels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hybrid_scope::WgTunnelConfig >*
WgConfigRequest::mutable_tunnels() {
  // @@protoc_insertion_point(field_mutable_list:hybrid_scope.WgConfigRequest.tunnels)
  return &_impl_.tunnels_;
}
inline const ::hybrid_scope::WgTunnelConfig& WgConfigRequest::_internal_tunnels(int index) const {
  return _impl_.tunnels_.Get(index);
}
inline const ::hybrid_scope::WgTunnelConfig& WgConfigRequest::tunnels(int index) const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgConfigRequest.tunnels)
  return _internal_tunnels(index);
}
inline ::hybrid_scope::WgTunnelConfig* WgConfigRequest::_internal_add_tunnels() {
  return _impl_.tunnels_.Add();
}
inline ::hybrid_scope::WgTunnelConfig* WgConfigRequest::add_tunnels() {
  ::hybrid_scope::WgTunnelConfig* _add = _internal_add_tunnels();
  // @@protoc_insertion_point(field_add:hybrid_scope.WgConfigRequest.tunnels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hybrid_scope::WgTunnelConfig >&
WgConfigRequest::tunnels() const {
  // @@protoc_insertion_point(field_list:hybrid_scope.WgConfigRequest.tunnels)
  return _impl_.tunnels_;
}

// -------------------------------------------------------------------

// WgStartupRequest

// int32 id = 1;
inline void WgStartupRequest::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t WgStartupRequest::_internal_id() const {
  return _impl_.id_;
}
inline int32_t WgStartupRequest::id() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgStartupRequest.id)
  return _internal_id();
}
inline void WgStartupRequest::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void WgStartupRequest::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgStartupRequest.id)
}

// -------------------------------------------------------------------

// WgShutdownRequest

// int32 id = 1;
inline void WgShutdownRequest::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t WgShutdownRequest::_internal_id() const {
  return _impl_.id_;
}
inline int32_t WgShutdownRequest::id() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgShutdownRequest.id)
  return _internal_id();
}
inline void WgShutdownRequest::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void WgShutdownRequest::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgShutdownRequest.id)
}

// -------------------------------------------------------------------

// WgExecRequest

// int32 id = 1;
inline void WgExecRequest::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t WgExecRequest::_internal_id() const {
  return _impl_.id_;
}
inline int32_t WgExecRequest::id() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgExecRequest.id)
  return _internal_id();
}
inline void WgExecRequest::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void WgExecRequest::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:hybrid_scope.WgExecRequest.id)
}

// string cmdline = 2;
inline void WgExecRequest::clear_cmdline() {
  _impl_.cmdline_.ClearToEmpty();
}
inline const std::string& WgExecRequest::cmdline() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgExecRequest.cmdline)
  return _internal_cmdline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgExecRequest::set_cmdline(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cmdline_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgExecRequest.cmdline)
}
inline std::string* WgExecRequest::mutable_cmdline() {
  std::string* _s = _internal_mutable_cmdline();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgExecRequest.cmdline)
  return _s;
}
inline const std::string& WgExecRequest::_internal_cmdline() const {
  return _impl_.cmdline_.Get();
}
inline void WgExecRequest::_internal_set_cmdline(const std::string& value) {
  
  _impl_.cmdline_.Set(value, GetArenaForAllocation());
}
inline std::string* WgExecRequest::_internal_mutable_cmdline() {
  
  return _impl_.cmdline_.Mutable(GetArenaForAllocation());
}
inline std::string* WgExecRequest::release_cmdline() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgExecRequest.cmdline)
  return _impl_.cmdline_.Release();
}
inline void WgExecRequest::set_allocated_cmdline(std::string* cmdline) {
  if (cmdline != nullptr) {
    
  } else {
    
  }
  _impl_.cmdline_.SetAllocated(cmdline, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cmdline_.IsDefault()) {
    _impl_.cmdline_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgExecRequest.cmdline)
}

// -------------------------------------------------------------------

// WgKeypair

// string public_key = 1;
inline void WgKeypair::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& WgKeypair::public_key() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgKeypair.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgKeypair::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgKeypair.public_key)
}
inline std::string* WgKeypair::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgKeypair.public_key)
  return _s;
}
inline const std::string& WgKeypair::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void WgKeypair::_internal_set_public_key(const std::string& value) {
  
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* WgKeypair::_internal_mutable_public_key() {
  
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* WgKeypair::release_public_key() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgKeypair.public_key)
  return _impl_.public_key_.Release();
}
inline void WgKeypair::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgKeypair.public_key)
}

// string private_key = 2;
inline void WgKeypair::clear_private_key() {
  _impl_.private_key_.ClearToEmpty();
}
inline const std::string& WgKeypair::private_key() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgKeypair.private_key)
  return _internal_private_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgKeypair::set_private_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.private_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgKeypair.private_key)
}
inline std::string* WgKeypair::mutable_private_key() {
  std::string* _s = _internal_mutable_private_key();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgKeypair.private_key)
  return _s;
}
inline const std::string& WgKeypair::_internal_private_key() const {
  return _impl_.private_key_.Get();
}
inline void WgKeypair::_internal_set_private_key(const std::string& value) {
  
  _impl_.private_key_.Set(value, GetArenaForAllocation());
}
inline std::string* WgKeypair::_internal_mutable_private_key() {
  
  return _impl_.private_key_.Mutable(GetArenaForAllocation());
}
inline std::string* WgKeypair::release_private_key() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgKeypair.private_key)
  return _impl_.private_key_.Release();
}
inline void WgKeypair::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    
  } else {
    
  }
  _impl_.private_key_.SetAllocated(private_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.private_key_.IsDefault()) {
    _impl_.private_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgKeypair.private_key)
}

// -------------------------------------------------------------------

// WgPublicKey

// string value = 1;
inline void WgPublicKey::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& WgPublicKey::value() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgPublicKey.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgPublicKey::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgPublicKey.value)
}
inline std::string* WgPublicKey::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgPublicKey.value)
  return _s;
}
inline const std::string& WgPublicKey::_internal_value() const {
  return _impl_.value_.Get();
}
inline void WgPublicKey::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* WgPublicKey::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* WgPublicKey::release_value() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgPublicKey.value)
  return _impl_.value_.Release();
}
inline void WgPublicKey::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgPublicKey.value)
}

// -------------------------------------------------------------------

// WgPrivateKey

// string value = 1;
inline void WgPrivateKey::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& WgPrivateKey::value() const {
  // @@protoc_insertion_point(field_get:hybrid_scope.WgPrivateKey.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WgPrivateKey::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hybrid_scope.WgPrivateKey.value)
}
inline std::string* WgPrivateKey::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:hybrid_scope.WgPrivateKey.value)
  return _s;
}
inline const std::string& WgPrivateKey::_internal_value() const {
  return _impl_.value_.Get();
}
inline void WgPrivateKey::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* WgPrivateKey::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* WgPrivateKey::release_value() {
  // @@protoc_insertion_point(field_release:hybrid_scope.WgPrivateKey.value)
  return _impl_.value_.Release();
}
inline void WgPrivateKey::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hybrid_scope.WgPrivateKey.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hybrid_scope

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hybrid_5fscope_2eproto
